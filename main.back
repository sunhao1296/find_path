package main

import (
	"fmt"
	"math"
	"strconv"
	"strings"
)

// 宝物类型定义
type Treasure struct {
	Type  string
	Value int
}

// 怪物类型定义
type Monster struct {
	Name    string
	HP      int
	ATK     int
	DEF     int
	Money   int
	EXP     int
	Point   int
	Special interface{}
}

// 区域定义
type Area struct {
	ID        int
	Treasures []*TreasureItem
	Neighbors []*Neighbor
	Positions [][2]int
}

// 宝物项定义
type TreasureItem struct {
	ID         int
	Type       string
	Value      int
	OriginalID int
}

// 邻居连接定义
type Neighbor struct {
	Area       int
	MonsterID  int
	Monster    *Monster
	MonsterPos [2]int
}

// 图结构定义
type Graph struct {
	Areas     []*Area
	StartArea int
	EndArea   int
	AreaMap   [][]int
}

// 全局宝物定义
type GlobalTreasure struct {
	ID         string
	AreaID     int
	Type       string
	Value      int
	OriginalID int
}

// 全局怪物定义
type GlobalMonster struct {
	Key            string
	ID             int
	Monster        *Monster
	Pos            [2]int
	ConnectedAreas []int
}

// 状态定义
type State struct {
	HP                 int
	ATK                int
	DEF                int
	DefeatedMonsters   map[int]bool
	CollectedTreasures map[int]bool
	Path               []string
}

// 搜索结果定义
type SearchResult struct {
	HP             int
	ATK            int
	DEF            int
	Path           []string
	DefeatedCount  int
	CollectedCount int
	Message        string
}

// 全局变量
var (
	gameMap = [][]int{
		{1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1},
		{1, 31, 0, 202, 28, 31, 201, 27, 202, 1, 27, 0, 1},
		{1, 203, 1, 1, 1, 206, 1, 1, 31, 204, 0, 1, 1},
		{1, 0, 27, 1, 28, 0, 203, 0, 206, 1, 31, 201, 1},
		{1, 1, 1, 1, 205, 1, 1, 31, 0, 1, 1, 1, 1},
		{1, 0, 204, 0, 0, 27, 1, 0, 203, 27, 1, 27, 1},
		{1, 31, 0, 1, 206, 1, 1, 206, 1, 1, 1, 31, 1},
		{1, 1, 28, 1, 28, 0, 1, 0, 0, 28, 1, 0, 1},
		{1, 31, 202, 1, 1, 203, 1, 1, 203, 1, 1, 204, 1},
		{1, 0, 201, 1, 31, 0, 1, 31, 0, 1, 0, 28, 1},
		{1, 1, 28, 1, 1, 1, 1, 1, 202, 1, 205, 1, 1},
		{1, 31, 0, 0, 0, 205, 0, 201, 0, 27, 0, 0, 1},
		{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
	}

	treasureMap = map[int]*Treasure{
		27: {Type: "atk", Value: 1},
		28: {Type: "def", Value: 1},
		31: {Type: "hp", Value: 50},
	}

	monsterMap = map[int]*Monster{
		201: {Name: "绿头怪", HP: 50, ATK: 19, DEF: 1, Money: 0, EXP: 0, Point: 0, Special: 0},
		202: {Name: "红头怪", HP: 40, ATK: 22, DEF: 0, Money: 0, EXP: 0, Point: 0, Special: []interface{}{}},
		203: {Name: "青头怪", HP: 35, ATK: 23, DEF: 3, Money: 0, EXP: 0, Point: 0, Special: 0},
		204: {Name: "怪王", HP: 44, ATK: 17, DEF: 2, Money: 10, EXP: 0, Point: 0, Special: []interface{}{}},
		205: {Name: "小蝙蝠", HP: 28, ATK: 25, DEF: 3, Money: 0, EXP: 0, Point: 0, Special: []interface{}{}},
		206: {Name: "大蝙蝠", HP: 33, ATK: 30, DEF: 1, Money: 0, EXP: 0, Point: 0, Special: 0},
	}

	start = [2]int{11, 6}
	end   = [2]int{0, 7}

	minATK    = 8
	maxATK    = 15
	minDEF    = 8
	maxDEF    = 15
	maxDamage = 9999

	damageCache = make(map[int]map[int]map[int]int)
)

// 地图转图转换器
type MapToGraphConverter struct {
	gameMap            [][]int
	rows               int
	cols               int
	treasureMap        map[int]*Treasure
	monsterMap         map[int]*Monster
	start              [2]int
	end                [2]int
	directions         [][2]int
	areas              []*Area
	monsterConnections map[string]map[int]bool
}

// 创建新的转换器
func NewMapToGraphConverter(gameMap [][]int, treasureMap map[int]*Treasure, monsterMap map[int]*Monster, start, end [2]int) *MapToGraphConverter {
	return &MapToGraphConverter{
		gameMap:            gameMap,
		rows:               len(gameMap),
		cols:               len(gameMap[0]),
		treasureMap:        treasureMap,
		monsterMap:         monsterMap,
		start:              start,
		end:                end,
		directions:         [][2]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}},
		areas:              []*Area{},
		monsterConnections: make(map[string]map[int]bool),
	}
}

// 检查位置是否有效
func (c *MapToGraphConverter) isValidPosition(pos [2]int) bool {
	x, y := pos[0], pos[1]
	return x >= 0 && x < c.rows && y >= 0 && y < c.cols && c.gameMap[x][y] != 1
}

// 转换地图为图
func (c *MapToGraphConverter) Convert() Graph {
	visited := make([][]int, c.rows)
	for i := range visited {
		visited[i] = make([]int, c.cols)
		for j := range visited[i] {
			visited[i][j] = -1
		}
	}

	areaCount := 0
	startArea := -1
	endArea := -1

	// 第一遍遍历：标记连通区域
	for i := 0; i < c.rows; i++ {
		for j := 0; j < c.cols; j++ {
			cellValue := c.gameMap[i][j]

			// 跳过墙、已访问位置和怪物位置
			if visited[i][j] != -1 || cellValue == 1 {
				continue
			}
			if _, exists := c.monsterMap[cellValue]; exists {
				continue
			}

			areaID := areaCount
			queue := [][2]int{{i, j}}
			visited[i][j] = areaID
			area := &Area{
				ID:        areaID,
				Treasures: []*TreasureItem{},
				Neighbors: []*Neighbor{},
				Positions: [][2]int{},
			}

			for len(queue) > 0 {
				pos := queue[0]
				queue = queue[1:]
				x, y := pos[0], pos[1]
				area.Positions = append(area.Positions, [2]int{x, y})

				// 检查是否为起点或终点
				if x == c.start[0] && y == c.start[1] {
					startArea = areaID
				}
				if x == c.end[0] && y == c.end[1] {
					endArea = areaID
				}

				// 检查是否有宝物
				cellVal := c.gameMap[x][y]
				if treasure, exists := c.treasureMap[cellVal]; exists {
					area.Treasures = append(area.Treasures, &TreasureItem{
						ID:         len(area.Treasures),
						Type:       treasure.Type,
						Value:      treasure.Value,
						OriginalID: cellVal,
					})
				}

				// 探索四个方向
				for _, dir := range c.directions {
					nx, ny := x+dir[0], y+dir[1]
					if nx < 0 || nx >= c.rows || ny < 0 || ny >= c.cols {
						continue
					}
					if visited[nx][ny] != -1 || c.gameMap[nx][ny] == 1 {
						continue
					}

					neighborVal := c.gameMap[nx][ny]
					if _, exists := c.monsterMap[neighborVal]; exists {
						// 记录怪物连接
						key := fmt.Sprintf("%d,%d", nx, ny)
						if c.monsterConnections[key] == nil {
							c.monsterConnections[key] = make(map[int]bool)
						}
						c.monsterConnections[key][areaID] = true
					} else {
						// 空地或宝物，加入当前区域
						visited[nx][ny] = areaID
						queue = append(queue, [2]int{nx, ny})
					}
				}
			}
			c.areas = append(c.areas, area)
			areaCount++
		}
	}

	// 第二遍遍历：添加怪物边
	for monsterPos, areas := range c.monsterConnections {
		areaList := make([]int, 0, len(areas))
		for area := range areas {
			areaList = append(areaList, area)
		}

		if len(areaList) >= 2 {
			parts := strings.Split(monsterPos, ",")
			x, _ := strconv.Atoi(parts[0])
			y, _ := strconv.Atoi(parts[1])
			monsterID := c.gameMap[x][y]
			monster := c.monsterMap[monsterID]

			// 为每个连接的区域添加边
			for i := 0; i < len(areaList); i++ {
				for j := i + 1; j < len(areaList); j++ {
					area1, area2 := areaList[i], areaList[j]

					neighbor1 := &Neighbor{
						Area:       area2,
						MonsterID:  monsterID,
						Monster:    monster,
						MonsterPos: [2]int{x, y},
					}
					neighbor2 := &Neighbor{
						Area:       area1,
						MonsterID:  monsterID,
						Monster:    monster,
						MonsterPos: [2]int{x, y},
					}

					c.areas[area1].Neighbors = append(c.areas[area1].Neighbors, neighbor1)
					c.areas[area2].Neighbors = append(c.areas[area2].Neighbors, neighbor2)
				}
			}
		}
	}

	return Graph{
		Areas:     c.areas,
		StartArea: startArea,
		EndArea:   endArea,
		AreaMap:   visited,
	}
}

// 初始化伤害缓存
func initDamageCache() {
	for atk := minATK; atk <= maxATK; atk++ {
		damageCache[atk] = make(map[int]map[int]int)
		for def := minDEF; def <= maxDEF; def++ {
			damageCache[atk][def] = make(map[int]int)
			for monsterID := range monsterMap {
				monster := monsterMap[monsterID]
				playerDamage := atk - monster.DEF

				var damage int
				if playerDamage <= 0 {
					damage = maxDamage
				} else {
					monsterDamage := int(math.Max(0, float64(monster.ATK-def)))
					rounds := int(math.Ceil(float64(monster.HP)/float64(playerDamage))) - 1
					damage = rounds * monsterDamage
				}

				damageCache[atk][def][monsterID] = damage
			}
		}
	}
}

// 获取预计算的伤害值
func getDamage(playerATK, playerDEF, monsterID int) int {
	return damageCache[playerATK][playerDEF][monsterID]
}

// 寻找最优路径
func findOptimalPath(graph Graph, startArea, endArea, initialHP, initialATK, initialDEF, requiredATK, requiredDEF int) SearchResult {
	// 获取所有怪物和宝物
	allMonsters := []GlobalMonster{}
	allTreasures := []GlobalTreasure{}

	for _, area := range graph.Areas {
		// 收集宝物
		for idx, treasure := range area.Treasures {
			allTreasures = append(allTreasures, GlobalTreasure{
				ID:         fmt.Sprintf("%d-%d", area.ID, idx),
				AreaID:     area.ID,
				Type:       treasure.Type,
				Value:      treasure.Value,
				OriginalID: treasure.OriginalID,
			})
		}

		// 收集怪物
		for _, neighbor := range area.Neighbors {
			monsterKey := fmt.Sprintf("%d,%d", neighbor.MonsterPos[0], neighbor.MonsterPos[1])
			found := false
			for _, m := range allMonsters {
				if m.Key == monsterKey {
					found = true
					break
				}
			}
			if !found {
				allMonsters = append(allMonsters, GlobalMonster{
					Key:            monsterKey,
					ID:             neighbor.MonsterID,
					Monster:        neighbor.Monster,
					Pos:            neighbor.MonsterPos,
					ConnectedAreas: []int{},
				})
			}
		}
	}

	// 为每个怪物找出连接的区域
	for _, area := range graph.Areas {
		for _, neighbor := range area.Neighbors {
			monsterKey := fmt.Sprintf("%d,%d", neighbor.MonsterPos[0], neighbor.MonsterPos[1])
			for i := range allMonsters {
				if allMonsters[i].Key == monsterKey {
					// 添加当前区域
					found := false
					for _, areaID := range allMonsters[i].ConnectedAreas {
						if areaID == area.ID {
							found = true
							break
						}
					}
					if !found {
						allMonsters[i].ConnectedAreas = append(allMonsters[i].ConnectedAreas, area.ID)
					}

					// 添加邻居区域
					found = false
					for _, areaID := range allMonsters[i].ConnectedAreas {
						if areaID == neighbor.Area {
							found = true
							break
						}
					}
					if !found {
						allMonsters[i].ConnectedAreas = append(allMonsters[i].ConnectedAreas, neighbor.Area)
					}
				}
			}
		}
	}

	// 计算可访问区域
	getAccessibleAreas := func(defeatedMonsters map[int]bool) map[int]bool {
		accessible := make(map[int]bool)
		accessible[startArea] = true
		queue := []int{startArea}

		for len(queue) > 0 {
			currentArea := queue[0]
			queue = queue[1:]

			// 检查每个怪物
			for monsterIdx, monster := range allMonsters {
				if defeatedMonsters[monsterIdx] { // 怪物已被击败
					for _, areaID := range monster.ConnectedAreas {
						if areaID == currentArea {
							for _, connectedAreaID := range monster.ConnectedAreas {
								if !accessible[connectedAreaID] {
									accessible[connectedAreaID] = true
									queue = append(queue, connectedAreaID)
								}
							}
						}
					}
				}
			}
		}

		return accessible
	}

	// 计算可收集的宝物
	getCollectibleTreasures := func(accessibleAreas map[int]bool, collectedTreasures map[int]bool) []int {
		collectible := []int{}
		for idx, treasure := range allTreasures {
			if !collectedTreasures[idx] && accessibleAreas[treasure.AreaID] {
				collectible = append(collectible, idx)
			}
		}
		return collectible
	}

	// 状态编码
	encodeState := func(defeatedMonsters, collectedTreasures map[int]bool) string {
		state := ""
		// 怪物状态
		for i := 0; i < len(allMonsters); i++ {
			if defeatedMonsters[i] {
				state += "1"
			} else {
				state += "0"
			}
		}
		state += "|"
		// 宝物状态
		for i := 0; i < len(allTreasures); i++ {
			if collectedTreasures[i] {
				state += "1"
			} else {
				state += "0"
			}
		}
		return state
	}

	// 应用宝物效果
	applyTreasures := func(hp, atk, def int, treasureIndices []int) (int, int, int, []string) {
		newHP, newATK, newDEF := hp, atk, def
		applied := []string{}

		for _, idx := range treasureIndices {
			treasure := allTreasures[idx]
			applied = append(applied, fmt.Sprintf("%s+%d", treasure.Type, treasure.Value))
			if treasure.Type == "hp" {
				newHP += treasure.Value
			} else if treasure.Type == "atk" {
				newATK += treasure.Value
			} else if treasure.Type == "def" {
				newDEF += treasure.Value
			}
		}

		return newHP, newATK, newDEF, applied
	}

	// DP表
	dp := make(map[string]State)

	// 初始状态
	initialDefeated := make(map[int]bool)
	initialCollected := make(map[int]bool)
	initialAccessible := getAccessibleAreas(initialDefeated)
	initialCollectible := getCollectibleTreasures(initialAccessible, initialCollected)

	// 收集初始可达的宝物
	newHP, newATK, newDEF, applied := applyTreasures(initialHP, initialATK, initialDEF, initialCollectible)
	newInitialCollected := make(map[int]bool)
	for k, v := range initialCollected {
		newInitialCollected[k] = v
	}
	for _, idx := range initialCollectible {
		newInitialCollected[idx] = true
	}

	initialStateKey := encodeState(initialDefeated, newInitialCollected)
	path := []string{fmt.Sprintf("起点区域%d", startArea)}
	if len(applied) > 0 {
		path = append(path, fmt.Sprintf("收集宝物: %s", strings.Join(applied, ", ")))
	}

	dp[initialStateKey] = State{
		HP:                 newHP,
		ATK:                newATK,
		DEF:                newDEF,
		DefeatedMonsters:   initialDefeated,
		CollectedTreasures: newInitialCollected,
		Path:               path,
	}

	// BFS搜索
	queue := []string{initialStateKey}
	visited := make(map[string]bool)
	visited[initialStateKey] = true

	var bestResult *SearchResult
	iterations := 0
	maxIterations := 50000000

	for len(queue) > 0 && iterations < maxIterations {
		iterations++
		stateKey := queue[0]
		queue = queue[1:]
		state, exists := dp[stateKey]

		if !exists {
			continue
		}

		// 检查是否满足胜利条件
		accessibleAreas := getAccessibleAreas(state.DefeatedMonsters)
		if accessibleAreas[endArea] && state.ATK >= requiredATK && state.DEF >= requiredDEF {
			if bestResult == nil || state.HP > bestResult.HP {
				newPath := make([]string, len(state.Path))
				copy(newPath, state.Path)
				newPath = append(newPath, fmt.Sprintf("到达终点区域%d (ATK:%d/%d, DEF:%d/%d)",
					endArea, state.ATK, requiredATK, state.DEF, requiredDEF))

				bestResult = &SearchResult{
					HP:             state.HP,
					ATK:            state.ATK,
					DEF:            state.DEF,
					Path:           newPath,
					DefeatedCount:  len(state.DefeatedMonsters),
					CollectedCount: len(state.CollectedTreasures),
				}
			}
		}

		// 尝试击败怪物
		for monsterIdx, monster := range allMonsters {
			if state.DefeatedMonsters[monsterIdx] {
				continue // 已击败
			}

			// 检查怪物是否可达
			canReachMonster := false
			for _, areaID := range monster.ConnectedAreas {
				if accessibleAreas[areaID] {
					canReachMonster = true
					break
				}
			}

			if !canReachMonster {
				continue
			}

			// 计算战斗伤害
			damage := getDamage(state.ATK, state.DEF, monster.ID)
			if damage >= state.HP {
				continue // 无法击败
			}

			newHP := state.HP - damage
			newDefeated := make(map[int]bool)
			for k, v := range state.DefeatedMonsters {
				newDefeated[k] = v
			}
			newDefeated[monsterIdx] = true

			// 计算击败怪物后的新可达区域和可收集宝物
			newAccessible := getAccessibleAreas(newDefeated)
			newCollectible := getCollectibleTreasures(newAccessible, state.CollectedTreasures)

			// 应用新宝物
			finalHP, finalATK, finalDEF, treasureApplied := applyTreasures(newHP, state.ATK, state.DEF, newCollectible)
			finalCollected := make(map[int]bool)
			for k, v := range state.CollectedTreasures {
				finalCollected[k] = v
			}
			for _, idx := range newCollectible {
				finalCollected[idx] = true
			}

			newStateKey := encodeState(newDefeated, finalCollected)

			// 检查是否是更优状态
			existingState, exists := dp[newStateKey]
			if !exists || finalHP > existingState.HP {
				newPath := make([]string, len(state.Path))
				copy(newPath, state.Path)
				newPath = append(newPath, fmt.Sprintf("击败%s@[%d,%d] (伤害:%d, HP:%d)",
					monster.Monster.Name, monster.Pos[0], monster.Pos[1], damage, finalHP))

				if len(treasureApplied) > 0 {
					newPath = append(newPath, fmt.Sprintf("收集宝物: %s", strings.Join(treasureApplied, ", ")))
				}

				dp[newStateKey] = State{
					HP:                 finalHP,
					ATK:                finalATK,
					DEF:                finalDEF,
					DefeatedMonsters:   newDefeated,
					CollectedTreasures: finalCollected,
					Path:               newPath,
				}

				if !visited[newStateKey] {
					visited[newStateKey] = true
					queue = append(queue, newStateKey)
				}
			}
		}
	}

	if bestResult != nil {
		fmt.Printf("\n=== 找到最优解 ===\n")
		fmt.Printf("最终属性: HP=%d, ATK=%d, DEF=%d\n", bestResult.HP, bestResult.ATK, bestResult.DEF)
		fmt.Printf("\n路径步骤:\n")
		for i, step := range bestResult.Path {
			fmt.Printf("%d. %s\n", i+1, step)
		}
		return *bestResult
	} else {
		message := "无法达到要求的属性并到达终点"
		if maxATK < requiredATK || maxDEF < requiredDEF {
			message = "原因: 宝物不足，无法达到要求属性"
		} else {
			message = "原因: 无法在保持足够HP的情况下到达终点"
		}
		fmt.Println(message)
		return SearchResult{
			HP:      -1,
			Path:    []string{"未找到有效路径"},
			Message: fmt.Sprintf("无法达到要求的属性 (ATK>=%d, DEF>=%d) 并到达终点", requiredATK, requiredDEF),
		}
	}
}

func main() {
	// 初始化伤害缓存
	initDamageCache()

	// 创建转换器并运行测试
	converter := NewMapToGraphConverter(gameMap, treasureMap, monsterMap, start, end)
	graph := converter.Convert()
	result := findOptimalPath(graph, graph.StartArea, graph.EndArea, 219, 8, 8, 15, 15)

	fmt.Printf("最终属性: HP=%d\n", result.HP)
	fmt.Printf("\n路径步骤:\n")
	for i, step := range result.Path {
		fmt.Printf("%d. %s\n", i+1, step)
	}
}
